tic;
clc;
clear all;
%   Este código de tomografia é usado para simular medições
%   feito em um estado óptico de "cat-Schrodinger"para encontrar o máximo
%   Estado de verossimilhança para esse conjunto de medições.
%   Na reconstrução, usamos histogramas com medidas de quadratura das
%   respectivas fases de medição gerando uma matriz com linhas(ângulo,
%   centro do bin, número de contagens no bin) e a partir dessa matriz
%   fizemos um processo de optimização para calcular a fidelidade do estado
%   verdadeiro e o novo estado gerado pelo histograma.
%   O espaço de estado dimensional infinito para o oscilador harmônico será
%   Representado na base do número de fótons.
%   Vamos truncar o espaço de Hilbert em fótons maxPhotonNumber
  
% This tomography code is used to simulate measurements made in a "cat-Schrodinger" optical state
% to find the maximum likelihood state for this set of measurements.
% In the reconstruction, we use histograms with measures of quadrature of the respective measurement
% phases generating a matrix with lines (angle, center of the bin, number of counts in the bin) and from this matrix we made an optimization process to calculate the fidelity of the true state and The new state generated by the histogram. 
% The infinite dimensional state space for the harmonic oscillator will be represented 
% on the basis of the number of photons. 


% W será o vetor com as diferenças em cada simulação das respectivas
% fidelidades (rhoML2, rho)-(rhohistogram, rho) calculadas 100 vezes.

% W will be the vector with the differences in each simulation of the respective fidelities
% (rhoML2, rho) - (rhohistogram, rho) calculated 100 times.

W = zeros(100,1)
for k = 1:100;
    
    
 % Let's truncate Hilbert space into photons maxPhotonNumber
maxPhotonNumber = 10;

% Primeiro, pré-computar um lote de números, como coeficientes para Hermite polinômios fatoriais, coeficientes binomiais.

% First, pre-compute a lot of numbers, such as coefficients for Hermite
% polynomials factorials, bi,nomial coefficients.

S = init_tables(maxPhotonNumber);

% Faça o vetor do estado para o estado do gato de Schrodinger.
% Make state vector for Schrodinger cat state

% amplitude of coherent states in the superposition
alpha = 1;  % Amplitude de estados coerentes na superposição

% phase between superposition
phase = 0;  % Fase entre a superposição


psi = generate_cat_vector(alpha, phase, S);
% O estado do gato de Schrodinger sofre de alguma perda passando por
%   um meio com 80% de eficiência.

% The Schrodinger cat state suffers from some loss by passing through a
% medium with 80 % efficiency.
etaState = 0.8;

rho = apply_loss(psi,etaState,S);

% Agora ele deve ser representado por uma matriz de densidade, rho.
%  Escolhemos 20 fases igualmente espaçados em que o nosso detector
%  mede este estado.

% Now it should be represented by a density matrix, rho. 
% We chose 20 equally spaced phases where our detector measures this state.

nMeasurements = 20000;

% Number of equally spaced angles
m = 20;% Número de ângulos igualmente espaçados
                angles = pi*[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]/m; 
               angles = repmat(angles,1,ceil (nMeasurements/m)); 
                angles = angles(1:nMeasurements).';
                

% A eficiência do detector é de 90 %.

% The efficiency of the detector is 90%.
etaDetector = 0.9;

% Agora, fazemos as medições do estado rho. Observe que temos que especificar
% Resultados de medição máximo e mínimo possíveis -7 e 7.

% Now, we make the measurements of state rho.  Notice we have to specify
% maximum and minimum possible measurement results -7 and 7.

samples = homodyne_samples(-7,7,etaDetector,angles,rho,S);

% Estrutura contendo o elemento POVM correspondente a cada medida
% resultado. Observe que os POVMs não são projetores puros.
% A eficiência do detector foi incluída no cálculo dos POVMs.

% Structure containing the POVM element corresponding to each measurement
% result.  Note that the POVMs are not pure projectors.  The homodyne
% detector's efficiency has been included in the computation of the POVMs.

Povms = make_measurement_struct(samples,etaDetector,S);

% Agora vamos usar o algoritmo R * rho * R até termos feito 2000 iterações
% Ou chegarmos a parar a diferença 0.01 (o que ocorrer primeiro).
% A intercepção é um limite superior da diferença entre o verdadeiro
% Log-verossimilhança máxima e a log-verossimilhança do estado de iterações.

% Now we will use the R*rho*R algorithm until we have done 2000 iterations
% or we reach stoppingCriterion 0.01 (whichever happens first).
% stoppingCriterion is an upper bound on the difference between the true
% maximum log-likelihood and the log-likelihood of that iterations's state.

 maxIterations = 2000;
 stoppingCriterion = 0.01;
    

%  [rhoML1, Diagnostics] = rrhor_optimization(samples, S, etaDetector, 0, maxIterations, stoppingCriterion, []);
%  Saída é o estado de máxima verossimilhança, rhoML e uma estrutura grande
%   de diagnósticos contendo informações sobre o progresso de cada iteração.
% 
%   Em vez de usar R * rho * R, podemos usar uma combinação de R * rho * R seguido
%   Por iterações de nosso novo algoritmo, a ascensão gradiente regularizada.
%   Isso geralmente é mais rápido, especialmente se você quiser estar no
%   Verdadeiro estado de máxima verossimilhança.

% output is the maximum likelihood state, rhoML, and a big structure
% Diagnostics containing information about each iterations's progress.

% Rather than using R*rho*R, we can use a combination of R*rho*R followed
% by iterations of our new algorithm, the regularized gradient ascent.
% This is usually faster, especially if you want to be very close to the
% true maximum likelihood state.

[rhoML2, Diagnostics ] = combined_optimization( samples, S, etaDetector, 0, maxIterations, stoppingCriterion);
 
    
% Fidelidade entre o estado verdadeiro e o estado estimado.

% Fidelity of true state and estimate
fidelity(rhoML2, rho)


b=1000;
m=20;
%Constrói a matriz M que tem como linhas(ângulo, centro do bin,número de contagens no bin) 

% It constructs the matrix M that has as lines (angle, center of the bin, number of counts in the bin)
M = matrix_histogram(samples,b,m);


Povmshistogram = make_measurement_struct(M,etaDetector,S);

% [rhoML1, Diagnostics] = rrhor_optimization(M, S, etaDetector, 0, maxIterations, stoppingCriterion, []);

[rhohistogram, Diagnostics] = combined_optimization( M, S, etaDetector, 0, maxIterations, stoppingCriterion);

% Calcula a fidelidade entre o estado verdadeiro e o estado reconstruído
% usando o histograma

% Calculates the fidelity between the true state and the reconstructed state using the histogram

fidelity(rhohistogram, rho)


 W(k)= fidelity(rhoML2, rho)-fidelity(rhohistogram, rho);

end

% Calcula a média das diferenças entre as fidelidades 
% (rhoML2,rho)-(rhohistogram, rho)

% Calculates the mean of the differences between the fidelities
% (rhoML2, rho) - (rhohistogram, rho)

mean(W);

% Calcula o desvio padrão da diferença das fidelidades
% (rhoML2-rhohistogram)

% Calculates the standard deviation of the fidelity difference (rhoML2-rhohistogram)
D=std(W);
toc;