%   Este código de tomografia é usado para simular medições
%   feito em um estado óptico de "cat-Schrodinger"para encontrar o máximo
%   Estado de verossimilhança para esse conjunto de medições.
%   Na reconstrução, usamos histogramas com medidas de quadratura das
%   respectivas fases de medição gerando uma matriz com linhas(ângulo,
%   centro do bin, número de contagens no bin) e a partir dessa matriz
%   fizemos um processo de optimização para calcular a fidelidade do estado
%   verdadeiro e o novo estado gerado pelo histograma.
%  Calculamos a fidelidade entre o estado estimado de máxima verossimilhança
%  com o estado puro (psi) assim como a fidelidade entre o estado estimado usando histograma  com o estado puro (psi).
%   O espaço de estado dimensional infinito para o oscilador harmônico será
%   Representado na base do número de fótons.
%   Vamos truncar o espaço de Hilbert em fótons maxPhotonNumber

% This tomography code is used to simulate measurements made in a "cat-Schrodinger" optical state
% to find the maximum likelihood state for this set of measurements.
% In the reconstruction, we use histograms with measures of quadrature of the respective measurement
% phases generating a matrix with lines (angle, center of the bin, number of counts in the bin) and from
% this matrix we made an optimization process to calculate the fidelity of the true state and The new state generated by the histogram.
% We calculated the fidelity between the estimated state of maximum likelihood with the pure state (psi) as well as the fidelity between
% the estimated state using histogram with the pure state (psi).
% The infinite dimensional state space for the harmonic oscillator will be represented
% on the basis of the number of photons.

tic;
clc;
clear;
%Maximum number of photons
maxPhotonNumber    = 10;

% Number of measurements
numMeasurements    = 20000;

% Simulates the reconstruction of the quantum state using the Scott's Method and the bins number method determined for the histogram
numBins            = 100;
method             = 2;
option             = [method, numBins];

% Number of simulations
numSim             = 100;

etaDetector        = 0.9;
maxIterations      = 2000;
stoppingCriterion  = 0.01;
alpha              = 1;
phase              = 0;
etaState           = 0.8;

numAngles          = 20;

for i=1:length(maxPhotonNumber),
    for k=1:length(numMeasurements),
         for j=1:length(option),
            
            fileName1 = ['maxPhNum',num2str(maxPhotonNumber(i)),'op',num2str(option(j)),'nM',num2str(numMeasurements(k)),'.mat'];
            
            if exist(fileName1,'file') == 2,
                load(fileName1);
            else
                fML2                = zeros(numSim,1);
                fHistogram          = zeros(numSim,1);
                fHistogramPsi       = zeros(numSim,1);
                fML2Psi             = zeros(numSim,1);
                fidelityDiff        = zeros(numSim,1);
                timeML2             = zeros(numSim,1);
                timeMhistogram      = zeros(numSim,1);
                timeRhoHistogram    = zeros(numSim,1);
                t                   = 1;
                
                save(fileName1);
            end
            
            angles = pi*(0:numAngles-1)/numAngles;
            angles = repmat(angles,1, ceil(numMeasurements(k)/numAngles));
            angles = angles(1:numMeasurements(k))';
            
            while t <= numSim,
                fprintf(['Iteraction ',num2str(t), '\n']);
                
                tic;
                S   = init_tables(maxPhotonNumber(i));
                psi = generate_cat_vector(alpha, phase, S);
                Rho = apply_loss(psi,etaState,S);
                
                Samples = homodyne_samples(-7,7,etaDetector,angles,Rho,S);
                
                tic;
                [RhoML2, Diagnostics] = combined_optimization( Samples, S, etaDetector, 0, maxIterations, stoppingCriterion);
                timeML2(t) = toc;
                
                fML2(t) = fidelity(RhoML2, Rho);

                tic;
                MHistogram = matrix_histogram(Samples, option(j));
                timeMhistogram(t) = toc;
                
                tic;
                [RhoHistogram, Diagnostics] = combined_optimization( MHistogram, S, etaDetector, 0, maxIterations, stoppingCriterion);
                timeRhoHistogram(t) = toc;
                
                fHistogram(t)       = fidelity(RhoHistogram, Rho);
                fHistogramPsi(t)    = fidelity(RhoHistogram, psi);
                fML2Psi(t)          = fidelity(RhoML2,psi);
                
                fidelityDiff(t)     = fML2(t)-fHistogram(t); 
                wHistogram          = mean(fidelityDiff);  % Average difference between fidelity  
                Dhistogram          = std(fidelityDiff);   % Standard deviation between the differences of loyalties
                meanFML2                = mean(fML2);      % Average fidelity between Rho and RhoML2
                meanFHistogram      = mean(fHistogram);    % Average fidelity between Rho and RhoHistogram(RhoHistogram(100 bins); RhoHistogram(Scott))
                meanFML2psi         = mean(fML2Psi);       % Average fidelity between RhoML2 and Psi
                meanFHistogramPsi       = mean(fHistogramPsi); % Average fidelity between Rho and RhoML2
                meanTimeML2             = mean(timeML2);       % Average time of construction of RhoML2
                meanTimeMHistogram      = mean(timeMhistogram);% Average time of construction of Matrix_Histogram
                meanTimeRhoHistogram    = mean(timeRhoHistogram); % Average time of construction of RhoHistogram
                stdFHistogram           = std(fHistogram);        % Standard deviation of fidelity(RhoHistogram,Rho)
                stdFML2                 = std(fML2);              % Standard deviation of fidelity(RhoML2,Rho)
                
                home;
                fprintf('>> Progress: %.2f%%\n', t/numSim*100);
                t=t+1;
                
                save(fileName1);
            end
        end
    end
end