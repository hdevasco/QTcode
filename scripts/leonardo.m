%   Este código de tomografia é usado para simular medições
%   feito em um estado óptico de "cat-Schrodinger"para encontrar o máximo
%   Estado de verossimilhança para esse conjunto de medições.
%   Na reconstrução, usamos histogramas com medidas de quadratura das
%   respectivas fases de medição gerando uma matriz com linhas(ângulo,
%   centro do bin, número de contagens no bin) e a partir dessa matriz
%   fizemos um processo de optimização para calcular a fidelidade do estado
%   verdadeiro e o novo estado gerado pelo histograma.
%  Calculamos a fidelidade entre o estado estimado de máxima verossimilhança
%  com o estado puro (psi) assim como a fidelidade entre o estado estimado usando histograma  com o estado puro (psi).
%   O espaço de estado dimensional infinito para o oscilador harmônico será
%   Representado na base do número de fótons.
%   Vamos truncar o espaço de Hilbert em fótons maxPhotonNumber

% This tomography code is used to simulate measurements made in a "cat-Schrodinger" optical state
% to find the maximum likelihood state for this set of measurements.
% In the reconstruction, we use histograms with measures of quadrature of the respective measurement
% phases generating a matrix with lines (angle, center of the bin, number of counts in the bin) and from
% this matrix we made an optimization process to calculate the fidelity of the true state and The new state generated by the histogram.
% We calculated the fidelity between the estimated state of maximum likelihood with the pure state (psi) as well as the fidelity between
% the estimated state using histogram with the pure state (psi).
% The infinite dimensional state space for the harmonic oscillator will be represented
% on the basis of the number of photons.

tic;
clc;
clear;

%Maximum number of photons
Mph = [10];


% Number of measurements
num_measurements = [20000];


% Simulates the reconstruction of the quantum state using the bins number method determined for the histogram
num_bins = [100];

for i=1:length(Mph),
    for j=1:length(num_bins),
        for k=1:length(num_measurements),
            
            fileName = ['maxnumberMph',num2str(Mph(i)),'b',num2str(num_bins(j)),'nM',num2str(num_measurements(k)),'.mat'];

 if exist(fileName,'file') == 2,
                load(fileName);
            else
                maxPhotonNumber = Mph(i);
                num_bins = num_bins(j);
                num_sim  = 100;
                FML2 = zeros(num_sim,1);
                Fhistogram = zeros(num_sim,1);
                Fhistogrampsi = zeros(num_sim,1);
                FML2psi = zeros(num_sim,1);
                Whistogram = zeros(num_sim,1);
                TimeML2 = zeros(num_sim,1);
                TimeMhistogram = zeros(num_sim,1);
                Timerhohistogram = zeros(num_sim,1);
               
                num_measurements       = num_measurements(k);
                etaDetector         = 0.9;
                maxIterations       = 2000;
                stoppingCriterion   = 0.01;
                alpha = 1;
                phase = 0;
                etaState = 0.8;
                t=1;
                
                save(fileName);
            end
            while t <= num_sim,

   fprintf('>> Generating angles... ');
                tic;
                
                num_angles = 20;% Number of equally spaced angles
                angles = pi*(0:num_angles-1)/num_angles;
                angles = repmat(angles,1,ceil (num_measurements/num_angles));
                angles = angles(1:num_measurements)';
                
                
                disp('>> init tables...');
                S = init_tables(maxPhotonNumber);
                
                disp('>> generate cat vector...');
                psi = generate_cat_vector(alpha, phase, S);
                
                disp('>> apply loss...');
                rho = apply_loss(psi,etaState,S);
                
             
                fprintf(['>> homodyne samples... iteraction ',num2str(t), '\n']);
                samples = homodyne_samples(-7,7,etaDetector,angles,rho,S);
               

                fprintf(['>> combined optimization... iteraction ',num2str(t), '\n']);
                tic;
                [rhoML2, Diagnostics] = combined_optimization( samples, S, etaDetector, 0, maxIterations, stoppingCriterion);
                
                TimeML2(t) = toc;
                
                % Fidelidade entre o estado verdadeiro e o estado estimado.
                
                % Fidelity of true state and estimate
                
                disp('>> fidelity (rhoML2 x rho)...');
                
                FML2(t) = fidelity(rhoML2, rho);
                
                
                disp('>> matrix histogram ...');
                
                option = [100] ;
               
                tic;
                
                Mhistogram = matrix_histogram(samples,option);
                TimeMhistogram(t) = toc;
              
               
                tic;
                [rhohistogram, Diagnostics] = combined_optimization( Mhistogram, S, etaDetector, 0, maxIterations, stoppingCriterion);
                Timerhohistogram(t) = toc;
             

                Fhistogram(t) = fidelity(rhohistogram, rho);
                 
                
                disp('>> fidelity (rhohistogram x psi)...');
                 
                  Fhistogrampsi(t) = fidelity(rhohistogram, psi);
                
                
                disp('>> fidelity (rhoML2 x psi)...');
                
                FML2psi(t) = fidelity(rhoML2,psi);
                
                Whistogram(t)= FML2(t)-Fhistogram(t);
                whistogram= mean(Whistogram);
                Dhistogram = std(Whistogram);
                fML2 = mean(FML2); 
                fhistogram = mean(Fhistogram);
                fML2psi = mean(FML2psi);
                fhistogrampsi = mean(Fhistogrampsi);
                timeML2 = mean(TimeML2); 
                timeMhistogram = mean(TimeMhistogram); 
                timerhohistogram = mean(Timerhohistogram);
                dFhistogram= std(Fhistogram); 
                
                
                home;
                fprintf('>> Progress: %.2f%%\n', t/num_sim*100);
                t=t+1;
                
                save(fileName);
            end
        end
    end
end             
                
% Simula a reconstrução do estado usando o método de largura ótima para o
% histograma
% 
% Simulates quantum state reconstruction using the optimal width method for the histogram

option = [2];

for i=1:length(Mph),
    for j=1:length(option),
        for k=1:length(num_measurements),
            
            fileName = ['maxnumberMph',num2str(Mph(i)),'option',num2str(option(j)),'nM',num2str(num_measurements(k)),'.mat'];
            
            if exist(fileName,'file') == 2,
                load(fileName);
            else
                maxPhotonNumber = Mph(i);
                num_bins = option(j);
                num_sim  = 100;
                Fscott = zeros(num_sim,1);
                Fscottpsi = zeros(num_sim,1);
                TimeMscott = zeros(num_sim,1);
                Timerhoscott= zeros(num_sim,1);
                Wscott = zeros(num_sim,1);
                
                
                num_measurements       = num_measurements(k);
                etaDetector         = 0.9;
                maxIterations       = 2000;
                stoppingCriterion   = 0.01;
                alpha = 1;
                phase = 0;
                etaState = 0.8;
                t=1;
                
                save(fileName);
            end
            while t <= num_sim,
                
               
                disp('>> matrix scott ...');
                

                option = 2 ;
                tic;
                
                Mscott = matrix_histogram(samples,option);
                TimeMscott(t) = toc;
              
               
                tic;
                [rhoscott, Diagnostics] = combined_optimization( Mscott, S, etaDetector, 0, maxIterations, stoppingCriterion);
                
                Timerhoscott(t) = toc;
              

                Fscott(t) = fidelity(rhoscott, rho);
                 
                
                disp('>> fidelity (rhoscott x psi)...');
                 
                  Fscottpsi(t) = fidelity(rhoscott, psi);
    
                
                Wscott(t)= FML2(t)-Fscott(t);
                wscott= mean(Wscott);
                Dscott = std(Wscott);
                fscott = mean(Fscott); 
                fscottpsi = mean(Fscottpsi); 
                timeMscott = mean(TimeMscott); 
                timerhoscott = mean(Timerhoscott); 
                dFscott= std(Fscott); 
                home;
                fprintf('>> Progress: %.2f%%\n', t/num_sim*100);
                t=t+1;
                
                save(fileName);
            end
        end
    end
end