tic;
clc;
clear;
%   Este código de tomografia é usado para simular medições
%   feito em um estado óptico de "cat-Schrodinger"para encontrar o máximo
%   Estado de verossimilhança para esse conjunto de medições.
%   Na reconstrução, usamos histogramas com medidas de quadratura das
%   respectivas fases de medição gerando uma matriz com linhas(ângulo,
%   centro do bin, número de contagens no bin) e a partir dessa matriz
%   fizemos um processo de optimização para calcular a fidelidade do estado
%   verdadeiro e o novo estado gerado pelo histograma.
%   O espaço de estado dimensional infinito para o oscilador harmônico será
%   Representado na base do número de fótons.
%   Vamos truncar o espaço de Hilbert em fótons maxPhotonNumber

% This tomography code is used to simulate measurements made in a "cat-Schrodinger" optical state
% to find the maximum likelihood state for this set of measurements.
% In the reconstruction, we use histograms with measures of quadrature of the respective measurement
% phases generating a matrix with lines (angle, center of the bin, number of counts in the bin) and from this matrix we made an optimization process to calculate the fidelity of the true state and The new state generated by the histogram.
% The infinite dimensional state space for the harmonic oscillator will be represented
% on the basis of the number of photons.



% W será o vetor com as diferenças em cada simulação das respectivas
% fidelidades (rhoML2, rho)-(rhohistogram, rho) calculadas 100 vezes.

% W will be the vector with the differences in each simulation of the respective fidelities
% (rhoML2, rho) - (rhohistogram, rho) calculated 100 times.

% Número de simulações
% Number of simulations
num_sim = 100;

W = zeros(num_sim,1);

% Matriz contendo os tempos de simulação pela estimativa não histograma
% Matrix containing the simulation times by the non-histogram estimate
T1= zeros(num_sim,1);

% Matriz contendo os tempos de simulação para a construção do histograma
% Matrix containing the simulation times by histogram estimation
T2= zeros(num_sim,1);

% Matriz contendo os tempos de estimação para a criação de (rhohistogram) a partir do cálculo dos POVM'S
% Matrix containing the estimation times for the creation of (rhohistogram) from the calculation of the POVM'S
T3= zeros(num_sim,1);

% Matriz contendo o cálculo das fidelidades de (rhoML2,rho)
% Matrix containing the fidelity calculation of (rhoML2, rho)
F1 = zeros(num_sim,1);

% Matriz contendo o cálculo das fidelidades de (rhohistogram,rho)
% Matrix containing the fidelity calculation of (rhohistogram, rho)
F2 = zeros(num_sim,1);

% Matriz contendo o cálculo da fidelidade de (rhohistogram, psi)
% Matrix containing the calculation of the fidelities of (rhohistogram, psi)
F3 = zeros(num_sim,1);

% Matriz contendo o cálculo da fidelidade de (rhoML2, psi)
% Matrix containing the calculation of the fidelities of (rhoML2, psi)
F4 = zeros(num_sim,1);
% Let's truncate Hilbert space into photons maxPhotonNumber
maxPhotonNumber = 10;

% Primeiro, pré-computar um lote de números, como coeficientes para Hermite polinômios fatoriais, coeficientes binomiais.

% First, pre-compute a lot of numbers, such as coefficients for Hermite
% polynomials factorials, bi,nomial coefficients.

%S = init_tables(maxPhotonNumber);

% Faça o vetor do estado para o estado do gato de Schrodinger.
% Make state vector for Schrodinger cat state

% amplitude of coherent states in the superposition
%alpha = 1;  % Amplitude de estados coerentes na superposição

% phase between superposition
% phase = 0;  % Fase entre a superposição

% O estado do gato de Schrodinger sofre de alguma perda passando por
%   um meio com 80% de eficiência.

% The Schrodinger cat state suffers from some loss by passing through a
% medium with 80 % efficiency.
% etaState = 0.8;

% Agora ele deve ser representado por uma matriz de densidade, rho.
%  Escolhemos 20 fases igualmente espaçados em que o nosso detector
%  mede este estado.

% Now it should be represented by a density matrix, rho.
% We chose 20 equally spaced phases where our detector measures this state.

nMeasurements = 20000;

% Number of equally spaced angles
m = 20;% Número de ângulos igualmente espaçados
angles = pi*[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]/m;
angles = repmat(angles,1,ceil (nMeasurements/m));
angles = angles(1:nMeasurements)';


% A eficiência do detector é de 90 %.

% The efficiency of the detector is 90%.
etaDetector = 0.9;
maxIterations = 2000;
stoppingCriterion = 0.01;
b=1000; % number of bins

alpha = 1;
phase = 0;
etaState = 0.8;



for k = 1:num_sim;
    
    disp('>> init tables...');
    S = init_tables(maxPhotonNumber);
    
    disp('>> generate cat vector...');
    psi = generate_cat_vector(alpha, phase, S);
    
    disp('>> apply loss...');
    rho = apply_loss(psi,etaState,S);
    
    
    % Agora, fazemos as medições do estado rho. Observe que temos que especificar
    % Resultados de medição máximo e mínimo possíveis -7 e 7.
    
    % Now, we make the measurements of state rho.  Notice we have to specify
    % maximum and minimum possible measurement results -7 and 7.
    
    fprintf(['>> homodyne samples... iteraction ',num2str(k), '\n']);
    samples = homodyne_samples(-7,7,etaDetector,angles,rho,S);
    
    % Estrutura contendo o elemento POVM correspondente a cada medida
    % resultado. Observe que os POVMs não são projetores puros.
    % A eficiência do detector foi incluída no cálculo dos POVMs.
    
    % Structure containing the POVM element corresponding to each measurement
    % result.  Note that the POVMs are not pure projectors.  The homodyne
    % detector's efficiency has been included in the computation of the POVMs.
    tic;
%     Povms = make_measurement_struct(samples,etaDetector,S);
    
    % Agora vamos usar o algoritmo R * rho * R até termos feito 2000 iterações
    % Ou chegarmos a parar a diferença 0.01 (o que ocorrer primeiro).
    % A intercepção é um limite superior da diferença entre o verdadeiro
    % Log-verossimilhança máxima e a log-verossimilhança do estado de iterações.
    
    % Now we will use the R*rho*R algorithm until we have done 2000 iterations
    % or we reach stoppingCriterion 0.01 (whichever happens first).
    % stoppingCriterion is an upper bound on the difference between the true
    % maximum log-likelihood and the log-likelihood of that iterations's state.
    
    
    
    
    %  [rhoML1, Diagnostics] = rrhor_optimization(samples, S, etaDetector, 0, maxIterations, stoppingCriterion, []);
    %  Saída é o estado de máxima verossimilhança, rhoML e uma estrutura grande
    %   de diagnósticos contendo informações sobre o progresso de cada iteração.
    %
    %   Em vez de usar R * rho * R, podemos usar uma combinação de R * rho * R seguido
    %   Por iterações de nosso novo algoritmo, a ascensão gradiente regularizada.
    %   Isso geralmente é mais rápido, especialmente se você quiser estar no
    %   Verdadeiro estado de máxima verossimilhança.
    
    % output is the maximum likelihood state, rhoML, and a big structure
    % Diagnostics containing information about each iterations's progress.
    
    % Rather than using R*rho*R, we can use a combination of R*rho*R followed
    % by iterations of our new algorithm, the regularized gradient ascent.
    % This is usually faster, especially if you want to be very close to the
    % true maximum likelihood state.
    fprintf(['>> combined optimization... iteraction ',num2str(k), '\n']);
    [rhoML2, Diagnostics ] = combined_optimization( samples, S, etaDetector, 0, maxIterations, stoppingCriterion);
    
    
    % Fidelidade entre o estado verdadeiro e o estado estimado.
    
    % Fidelity of true state and estimate
    disp('>> fidelity (samples)...');
    F1(k) = fidelity(rhoML2, rho);
    T1(k) = toc;
    
    
    %Constrói a matriz M que tem como linhas(ângulo, centro do bin,número de contagens no bin)
    
    % It constructs the matrix M that has as lines (angle, center of the bin, number of counts in the bin)
    tic;
    disp('>> matrix histogram ...');
    M = matrix_histogram(samples,b,m);
    
    T2(k) = toc;
    
    tic;
%     Povmshistogram = make_measurement_struct(M,etaDetector,S);
    
    % [rhoML1, Diagnostics] = rrhor_optimization(M, S, etaDetector, 0, maxIterations, stoppingCriterion, []);
    
    fprintf(['>> combined optimization (M)... iteraction ',num2str(k), '\n']);
    [rhohistogram, Diagnostics] = combined_optimization( M, S, etaDetector, 0, maxIterations, stoppingCriterion);
    
    % Calcula a fidelidade entre o estado verdadeiro e o estado reconstruído
    % usando o histograma
    
    % Calculates the fidelity between the true state and the reconstructed state using the histogram
    disp('>> fidelity (rhohistogram x rho)...');
    F2(k) = fidelity(rhohistogram, rho);
    T3(k) = toc;
    
    disp('>> fidelity (rhohistogram x psi)...');
    F3(k) = fidelity(rhohistogram, psi);
    
    disp('>> fidelity (rhoML2 x psi)...');
    F4(k) = fidelity(rhoML2,psi);
    
    W(k)= F1(k)-F2(k);
    
end

% Calcula a média das diferenças entre as fidelidades
% (rhoML2,rho)-(rhohistogram, rho)

% Calculates the mean of the differences between the fidelities
% (rhoML2, rho) - (rhohistogram, rho)

w = mean(W);

% Calcula a fidelidade média entre os estados (rhoML2,rho)
% Calculates the average fidelity between states (rhoML2,rho)
f1 = mean(F1);

% Calcula a fidelidade média entre os estados (rhohistogram,rho)
% Calculates the average fidelity between states (rhohistogram,rho)
f2 = mean(F2);


% Calcula a fidelidade média entre os estados (rhohistogram,psi)
% Calculates the average fidelity between states (rhohistogram, psi)
f3 = mean(F3);

% Calcula a fidelidade média entre os estados (rhoML2,psi)
% Calculates the average fidelity between states (rhoML2, psi)
f4 = mean(F4);

% Calcula o desvio padrão da diferença das fidelidades
% (rhoML2-rhohistogram)

% Calculates the standard deviation of the fidelity difference (rhoML2-rhohistogram)
D=std(W);

% Tempo médio para a criação de rhoML2 a partir dos POVM'S
% Average time for the creation of rhoML2 from the POVM'S
t1=mean(T1);

% Tempo médio para a criação do histograma
% Average time to create histogram
t2=mean(T2);

% Tempo médio para a criação de rhohistogram a partir dos POVM'S
% Average time to create rhohistogram from POVM'S
t3=mean(T3);

toc;